<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Sphere Organizer — Prototype (CRUD + AR/GLB)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0"/>
  <style>
    :root{--bg:#f3f6fb;--card:#fff;--muted:#6b7280;--accent:#2b6ef6}
    html,body{height:100%;margin:0;background:var(--bg);font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    .app{display:flex;flex-direction:column;height:100%}
    canvas{display:block; width:100%; height:calc(100vh - 90px);}
    .topbar{height:90px;display:flex;gap:12px;align-items:center;justify-content:space-between;padding:12px 16px;background:var(--card);box-shadow:0 8px 18px rgba(20,30,60,0.05)}
    .controls{display:flex;gap:8px;align-items:center}
    .btn{background:#fff;border:1px solid #e6eefb;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
    .btn.primary{background:var(--accent);color:#fff;border:0}
    .info{font-weight:700;color:#0b1b3b}
    .panel{position:fixed;right:16px;top:110px;background:var(--card);padding:12px;border-radius:10px;box-shadow:0 10px 30px rgba(20,30,60,0.08);min-width:260px;max-width:360px}
    .panel h3{margin:0 0 8px 0;font-size:14px}
    .zone-select{display:flex;flex-wrap:wrap;gap:6px;margin-bottom:8px}
    .zone-pill{padding:6px 8px;border-radius:999px;border:1px solid #e6eefb;background:#fbfdff;cursor:pointer;font-weight:600}
    .zone-pill.active{background:var(--accent);color:#fff;border:0}
    .item-row{display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-radius:8px;margin-bottom:6px;background:#f6f9ff;border:1px solid #eef3ff}
    .small{font-size:13px;color:var(--muted)}
    .muted{color:var(--muted)}
    .file-row{display:flex;gap:8px;align-items:center;margin-top:8px}
    input[type="text"]{padding:8px;border-radius:8px;border:1px solid #e6eefb;width:100%}
    textarea{width:100%;height:80px;border-radius:8px;padding:8px;border:1px solid #e6eefb}
    .footer{height:40px;background:transparent;display:flex;align-items:center;justify-content:center;color:var(--muted);font-size:13px}
    @media (max-width:900px){ .panel{position:fixed;left:10px;right:10px;top:auto;bottom:86px;max-width:none;} canvas{height:calc(100vh - 190px);} }
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div style="display:flex;flex-direction:column;">
        <div style="display:flex;gap:12px;align-items:center;">
          <div class="info">SPHERE — Prototype</div>
          <div class="small muted">Drag to spin • Tap a label to open zone • Center tap opens current zone</div>
        </div>
        <div class="small muted" style="margin-top:6px">Persistent demo — edits stored in browser (localStorage). Use Export / Import for sharing.</div>
      </div>

      <div class="controls">
        <button class="btn" id="prevBtn">Prev</button>
        <button class="btn" id="spinBtn">Spin</button>
        <button class="btn" id="nextBtn">Next</button>
        <button class="btn" id="randomBtn">Random</button>
        <button class="btn primary" id="enterArBtn">Enter AR</button>
        <button class="btn" id="exportGlbBtn">Export GLB</button>
      </div>
    </div>

    <canvas id="world"></canvas>

    <div class="footer">Tip: On iPhone, use Export GLB then open on the device to view in Quick Look (AR). Or try Enter AR if your browser supports WebXR.</div>
  </div>

  <!-- Right-side control panel -->
  <div class="panel" id="panel">
    <h3>Zones & Items</h3>
    <div class="zone-select" id="zoneSelect"></div>

    <div style="margin-top:8px;margin-bottom:8px">
      <input id="newItemText" type="text" placeholder="New item text (title)"/>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button class="btn primary" id="addItemBtn">Add Item</button>
        <button class="btn" id="exportJsonBtn">Export JSON</button>
        <button class="btn" id="importJsonBtn">Import JSON</button>
      </div>
      <input type="file" id="fileInput" style="display:none" accept=".json"/>
    </div>

    <div id="itemsList"></div>

    <div style="margin-top:12px" class="small muted">Controls: Add/Edit/Delete; Export JSON to share or Import to load friends' spheres.</div>
  </div>

  <!-- Overlay / Modal for zone details (touch fallback) -->
  <div id="overlay" style="display:none;position:fixed;left:0;top:0;right:0;bottom:0;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:9999">
    <div style="background:#fff;padding:14px;border-radius:8px;min-width:300px;max-width:90%">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
        <div style="font-weight:700" id="overlayTitle"></div>
        <button id="overlayClose" class="btn">Close</button>
      </div>
      <div id="overlayItems"></div>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  <!-- GLTFExporter (non-module legacy version) -->
  <script src="https://unpkg.com/three@0.158.0/examples/js/exporters/GLTFExporter.js"></script>
  <!-- ARButton (legacy non-module) — used if available -->
  <script src="https://unpkg.com/three@0.158.0/examples/js/ARButton.js"></script>

  <script>
  // --------- Data model & persistence ----------
  const ZONES = ["Ideas","Tasks","People","Rituals","Mindset","Someday"];
  const STORAGE_KEY = "sphere.v1.items";

  function defaultData(){
    return {
      "Ideas": ["Sketch concept","New scent idea","Pattern tweak"],
      "Tasks": ["Call Jenna","Order labels","Send sample"],
      "People": ["JHANE","Maeve","Arsallan"],
      "Rituals": ["Morning stretch","2-min breath","Evening notes"],
      "Mindset": ["Gratitude","Focus practice","Reflect"],
      "Someday": ["Visit Japan","Archive photos","Renew domain"]
    };
  }

  function loadData(){
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) { const d = defaultData(); localStorage.setItem(STORAGE_KEY, JSON.stringify(d)); return d; }
    try { return JSON.parse(raw); } catch(e){ console.error("parse error",e); const d=defaultData(); localStorage.setItem(STORAGE_KEY, JSON.stringify(d)); return d; }
  }
  function saveData(data){ localStorage.setItem(STORAGE_KEY, JSON.stringify(data)); }

  let data = loadData();
  // ---------- UI (panel) ----------
  const zoneSelectEl = document.getElementById('zoneSelect');
  const itemsListEl = document.getElementById('itemsList');
  const newItemText = document.getElementById('newItemText');
  const addItemBtn = document.getElementById('addItemBtn');
  const exportJsonBtn = document.getElementById('exportJsonBtn');
  const importJsonBtn = document.getElementById('importJsonBtn');
  const fileInput = document.getElementById('fileInput');
  const overlay = document.getElementById('overlay');
  const overlayTitle = document.getElementById('overlayTitle');
  const overlayItems = document.getElementById('overlayItems');
  const overlayClose = document.getElementById('overlayClose');

  let activeZoneIndex = 0;

  function renderZonePills(){
    zoneSelectEl.innerHTML = "";
    ZONES.forEach((z,i)=>{
      const btn = document.createElement('div');
      btn.className = "zone-pill" + (i===activeZoneIndex ? " active":"");
      btn.textContent = z;
      btn.addEventListener('click', ()=> { setActiveZone(i); snapToZone(i); });
      zoneSelectEl.appendChild(btn);
    });
  }
  function renderItemsPanel(){
    itemsListEl.innerHTML = "";
    const zone = ZONES[activeZoneIndex];
    const arr = data[zone] || [];
    arr.forEach((it, idx) => {
      const row = document.createElement('div');
      row.className = 'item-row';
      const left = document.createElement('div'); left.textContent = it;
      const right = document.createElement('div');
      const edit = document.createElement('button'); edit.className='btn'; edit.textContent='Edit'; edit.addEventListener('click', ()=> editItem(idx));
      const del = document.createElement('button'); del.className='btn'; del.textContent='Delete'; del.addEventListener('click', ()=> deleteItem(idx));
      right.appendChild(edit); right.appendChild(del);
      row.appendChild(left); row.appendChild(right);
      itemsListEl.appendChild(row);
    });
  }

  function setActiveZone(i){
    activeZoneIndex = ((i%ZONES.length)+ZONES.length)%ZONES.length;
    renderZonePills();
    renderItemsPanel();
  }
  function addItem(){
    const text = newItemText.value.trim();
    if(!text) return alert("Enter item text");
    const zone = ZONES[activeZoneIndex];
    data[zone] = data[zone] || [];
    data[zone].unshift(text);
    saveData(data);
    newItemText.value = "";
    renderItemsPanel();
    refreshPins(); // update 3D labels
  }
  function editItem(idx){
    const zone = ZONES[activeZoneIndex];
    const old = data[zone][idx];
    const val = prompt("Edit item text", old);
    if(val==null) return;
    data[zone][idx] = val;
    saveData(data);
    renderItemsPanel();
    refreshPins();
  }
  function deleteItem(idx){
    if(!confirm("Delete this item?")) return;
    const zone = ZONES[activeZoneIndex];
    data[zone].splice(idx,1);
    saveData(data);
    renderItemsPanel();
    refreshPins();
  }

  addItemBtn.addEventListener('click', addItem);
  newItemText.addEventListener('keydown', (e)=> { if(e.key==='Enter'){ addItem(); }});
  exportJsonBtn.addEventListener('click', ()=>{
    const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'sphere-data.json'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  });
  importJsonBtn.addEventListener('click', ()=> fileInput.click());
  fileInput.addEventListener('change', (ev)=>{
    const f = ev.target.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = function(){ try{ const parsed=JSON.parse(reader.result); data = parsed; saveData(data); setActiveZone(0); renderItemsPanel(); refreshPins(); alert("Imported!"); } catch(e){ alert("Invalid JSON"); }}
    reader.readAsText(f);
  });

  overlayClose.addEventListener('click', ()=> overlay.style.display='none');

  // init UI
  renderZonePills();
  renderItemsPanel();

  // ---------- Three.js scene ----------
  const canvas = document.getElementById('world');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50,2,0.1,2000);
  camera.position.set(0,0,600);
  const light = new THREE.HemisphereLight(0xffffff,0x666666,1.2);
  scene.add(light);

  const group = new THREE.Group();
  scene.add(group);

  const sphere = new THREE.Mesh(new THREE.SphereGeometry(200,64,64), new THREE.MeshStandardMaterial({color:0xf7fbff,metalness:0.02,roughness:0.7}));
  group.add(sphere);

  // markers & pins arrays
  let markers = [];
  let pins = [];

  function clearMarkers(){
    markers.forEach(m=> group.remove(m));
    markers=[];
    pins.forEach(p=> group.remove(p));
    pins=[];
  }

  // helper: spherical -> cartesian
  function sphericalToCartesian(radius, thetaDeg, phiDeg){
    const theta = THREE.MathUtils.degToRad(thetaDeg);
    const phi = THREE.MathUtils.degToRad(phiDeg);
    const x = radius * Math.cos(phi) * Math.cos(theta);
    const y = radius * Math.sin(phi);
    const z = radius * Math.cos(phi) * Math.sin(theta);
    return new THREE.Vector3(x,y,z);
  }

  // draw markers for zone labels and top item pins
  function refreshPins(){
    clearMarkers();
    // draw zone labels evenly around equator
    ZONES.forEach((z,i)=>{
      const theta = i*(360/ZONES.length);
      const pos = sphericalToCartesian(201, theta, 0);
      const canvas = makeLabelCanvas(z, {bg:"#eaf2ff", fg:"#15304f"});
      const tex = new THREE.CanvasTexture(canvas);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
      sprite.scale.set(canvas.width*0.18, canvas.height*0.18, 1);
      sprite.position.copy(pos);
      sprite.userData = { zoneIndex: i, label: z };
      sprite.center.set(0.5,0.5);
      group.add(sprite);
      markers.push(sprite);
    });

    // top item pins (first item from each zone)
    ZONES.forEach((z,i)=>{
      const first = (data[z] && data[z][0]) ? data[z][0] : "(empty)";
      const theta = i*(360/ZONES.length) + 18;
      const pos = sphericalToCartesian(202, theta, 12);
      const canvas = makeLabelCanvas(first, {bg:"#fff", fg:"#1b2a47"});
      const tex = new THREE.CanvasTexture(canvas);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
      sprite.scale.set(canvas.width*0.14, canvas.height*0.14, 1);
      sprite.position.copy(pos);
      sprite.center.set(0.5,0.5);
      group.add(sprite);
      pins.push(sprite);
    });
  }

  function makeLabelCanvas(text, opts){
    opts = opts || {};
    const bg = opts.bg || "#fff";
    const fg = opts.fg || "#112340";
    const padding = 12;
    const font = "bold 22px Arial";
    const measure = document.createElement('canvas');
    const mctx = measure.getContext('2d');
    mctx.font = font;
    const w = Math.max(80, Math.ceil(mctx.measureText(text).width + padding*2));
    const h = 44;
    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    // background rounded
    ctx.fillStyle = bg;
    roundRect(ctx, 0, 0, w, h, 10);
    ctx.fillStyle = fg;
    ctx.font = font;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, w/2, h/2+1);
    return canvas;
  }
  function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); }

  refreshPins();

  // resize
  function resize(){
    const w = canvas.clientWidth || window.innerWidth;
    const h = canvas.clientHeight || (window.innerHeight - 90);
    renderer.setSize(w,h);
    camera.aspect = w/h;
    camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', resize); resize();

  // drag/spin with inertia + snap to nearest zone
  let isDown = false, lastX = 0, velocity = 0, rotY = 0;
  const sensitivity = 0.008, damping = 0.95;
  let lastMoveTime = 0;
  let targetRotY = null;

  function pointerDown(e){
    isDown = true;
    lastX = e.touches ? e.touches[0].clientX : e.clientX;
    velocity = 0;
    targetRotY = null;
  }
  function pointerMove(e){
    if(!isDown) return;
    const x = e.touches ? e.touches[0].clientX : e.clientX;
    const dx = x - lastX;
    lastX = x;
    const delta = dx * sensitivity;
    rotY += delta;
    velocity = delta;
    lastMoveTime = performance.now();
  }
  function pointerUp(e){
    if(!isDown) return;
    isDown = false;
    // snap to zone after short delay (if velocity small)
    const now = performance.now();
    // compute nearest zone and set targetRotY to align it
    const nearest = nearestZoneFromRot(rotY);
    snapToZone(nearest);
  }

  canvas.addEventListener('mousedown', pointerDown);
  canvas.addEventListener('mousemove', pointerMove);
  window.addEventListener('mouseup', pointerUp);
  canvas.addEventListener('touchstart', pointerDown, {passive:true});
  canvas.addEventListener('touchmove', pointerMove, {passive:true});
  window.addEventListener('touchend', pointerUp);

  function nearestZoneFromRot(rY){
    // Map rotY to fraction 0..1
    const fraction = ((-rY / (2*Math.PI)) % 1 + 1) % 1;
    let idx = Math.round(fraction * ZONES.length) % ZONES.length;
    return idx;
  }

  // animate snap
  function snapToZone(zoneIdx){
    // compute current fraction and desired rotY so that zoneIdx is in front (0 angle)
    const desiredFraction = zoneIdx / ZONES.length;
    // current fraction
    const currentFrac = ((-rotY / (2*Math.PI)) % 1 + 1) % 1;
    // compute difference, but choose shortest rotation
    let diff = desiredFraction - currentFrac;
    if(diff > 0.5) diff -= 1;
    if(diff < -0.5) diff += 1;
    targetRotY = rotY - diff * 2*Math.PI;
  }

  // Next / Prev / Random / Spin buttons
  document.getElementById('prevBtn').addEventListener('click', ()=> { snapToZone((nearestZoneFromRot(rotY)-1 + ZONES.length)%ZONES.length); });
  document.getElementById('nextBtn').addEventListener('click', ()=> { snapToZone((nearestZoneFromRot(rotY)+1)%ZONES.length); });
  document.getElementById('randomBtn').addEventListener('click', ()=> { snapToZone(Math.floor(Math.random()*ZONES.length)); });
  document.getElementById('spinBtn').addEventListener('click', ()=> {
    // spinning fast a number of steps then snap
    let spins = 18 + Math.floor(Math.random()*12);
    let i = 0;
    const iv = setInterval(()=> {
      rotY -= (2*Math.PI)/ZONES.length;
      i++;
      if(i>=spins){ clearInterval(iv); snapToZone(nearestZoneFromRot(rotY)); }
    }, 60);
  });

  // center click: open overlay for current zone
  const raycaster = new THREE.Raycaster();
  const pointer = new THREE.Vector2();
  function onCanvasClick(e){
    const rect = renderer.domElement.getBoundingClientRect();
    const clientX = e.clientX ?? (e.touches && e.touches[0].clientX);
    const clientY = e.clientY ?? (e.touches && e.touches[0].clientY);
    pointer.x = ((clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = - ((clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);
    const intersects = raycaster.intersectObjects(markers.concat(pins), true);
    if(intersects.length){
      const obj = intersects[0].object;
      const zoneIdx = obj.userData.zoneIndex;
      if(zoneIdx !== undefined){
        // snap to that zone and open overlay
        snapToZone(zoneIdx);
        openOverlayForZone(zoneIdx);
      }
      return;
    }
    // click sphere -> open overlay for nearest zone
    const intersectsSphere = raycaster.intersectObject(sphere);
    if(intersectsSphere.length){
      const idx = nearestZoneFromRot(rotY);
      snapToZone(idx);
      openOverlayForZone(idx);
    }
  }

  canvas.addEventListener('click', onCanvasClick);
  canvas.addEventListener('touchend', (e)=> { if(e.changedTouches && e.changedTouches.length) onCanvasClick(e.changedTouches[0]); });

  function openOverlayForZone(idx){
    overlayTitle.textContent = ZONES[idx];
    overlayItems.innerHTML = "";
    (data[ZONES[idx]] || []).forEach(it => {
      const d = document.createElement('div'); d.className='item-row'; d.textContent = it;
      overlayItems.appendChild(d);
    });
    overlay.style.display = 'flex';
  }

  // ---------- render loop ----------
  function animate(){
    requestAnimationFrame(animate);
    // inertia
    if(!isDown && Math.abs(velocity) > 0.00001){
      rotY += velocity;
      velocity *= damping;
    }
    // apply target smoothing if snapping
    if(targetRotY !== null){
      // interpolate rotY -> targetRotY
      rotY += (targetRotY - rotY) * 0.18;
      if(Math.abs(targetRotY - rotY) < 0.0005){ rotY = targetRotY; targetRotY = null; velocity = 0; setActiveZone(nearestZoneFromRot(rotY)); }
    }
    group.rotation.y = rotY;
    renderer.render(scene, camera);
  }
  animate();

  // ---------- info panel sync ----------
  function setActiveZone(i){
    activeZoneIndex = ((i%ZONES.length)+ZONES.length)%ZONES.length;
    renderZonePills();
    renderItemsPanel();
  }
  setActiveZone(0);

  // ---------- refresh pins (after data changes) ----------
  function refreshPins(){
    // remove old ones
    clearMarkers();
    // rebuild
    // (recreate everything)
    // draw zone labels evenly around equator
    ZONES.forEach((z,i)=>{
      const theta = i*(360/ZONES.length);
      const pos = sphericalToCartesian(201, theta, 0);
      const canvas = makeLabelCanvas(z, {bg:"#eaf2ff", fg:"#15304f"});
      const tex = new THREE.CanvasTexture(canvas);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
      sprite.scale.set(canvas.width*0.18, canvas.height*0.18, 1);
      sprite.position.copy(pos);
      sprite.userData = { zoneIndex: i, label: z };
      sprite.center.set(0.5,0.5);
      group.add(sprite);
      markers.push(sprite);
    });

    // top item pins (first item from each zone)
    ZONES.forEach((z,i)=>{
      const first = (data[z] && data[z][0]) ? data[z][0] : "(empty)";
      const theta = i*(360/ZONES.length) + 18;
      const pos = sphericalToCartesian(202, theta, 12);
      const canvas = makeLabelCanvas(first, {bg:"#fff", fg:"#1b2a47"});
      const tex = new THREE.CanvasTexture(canvas);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
      sprite.scale.set(canvas.width*0.14, canvas.height*0.14, 1);
      sprite.position.copy(pos);
      sprite.center.set(0.5,0.5);
      group.add(sprite);
      pins.push(sprite);
    });
  }

  // ---------- GLB export ----------
  const gltfExporter = new THREE.GLTFExporter();
  document.getElementById('exportGlbBtn').addEventListener('click', ()=> {
    // build a small export scene (clone group)
    const exportScene = new THREE.Scene();
    // clone sphere and label sprites as simple meshes for glTF export
    const sClone = sphere.clone();
    exportScene.add(sClone);
    // add pin boxes to represent labels (simple meshes)
    const boxMat = new THREE.MeshStandardMaterial({color:0x2b6ef6});
    ZONES.forEach((z,i)=> {
      const geom = new THREE.BoxGeometry(8,8,2);
      const m = new THREE.Mesh(geom, boxMat);
      const pos = sphericalToCartesian(220, i*(360/ZONES.length), 0);
      m.position.copy(pos);
      exportScene.add(m);
    });

    gltfExporter.parse(exportScene, function(result){
      if(result instanceof ArrayBuffer){
        const blob = new Blob([result], {type: 'model/gltf-binary'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'sphere_scene.glb';
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      } else {
        // gltf JSON (unexpected)
        const text = JSON.stringify(result, null, 2);
        const blob = new Blob([text], {type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'sphere_scene.gltf';
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      }
    }, {binary:true});
  });

  // ---------- AR / WebXR (attempt) ----------
  const enterArBtn = document.getElementById('enterArBtn');
  enterArBtn.addEventListener('click', ()=> {
    if (navigator.xr && navigator.xr.isSessionSupported) {
      navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
        if(supported && THREE.ARButton){
          // Use ARButton to request session
          document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));
          // ARButton will show UI; we also attempt to enter directly
        } else {
          alert("WebXR AR not available in this browser/device. Please try on a compatible device (Chrome on Android with ARCore) or use Export GLB and open on your phone for Quick Look / AR.");
        }
      }).catch(()=> {
        alert("WebXR check failed — try Export GLB for Quick Look or use a compatible AR browser.");
      });
    } else {
      alert("WebXR not supported in this browser. Use Export GLB and open on mobile (iOS Quick Look or AR viewer) to preview in AR.");
    }
  });

  // ---------- helper utils ----------
  function makeLabelCanvas(text, opts){
    opts = opts || {};
    const bg = opts.bg || "#fff";
    const fg = opts.fg || "#112340";
    const padding = 12;
    const font = "bold 20px Arial";
    const measure = document.createElement('canvas');
    const mctx = measure.getContext('2d');
    mctx.font = font;
    const w = Math.max(80, Math.ceil(mctx.measureText(text).width + padding*2));
    const h = 44;
    const canvas = document.createElement('canvas');
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = bg; roundRect(ctx,0,0,w,h,10);
    ctx.fillStyle = fg;
    ctx.font = font;
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(text, w/2, h/2 + 1);
    return canvas;
  }
  function sphericalToCartesian(radius, thetaDeg, phiDeg){ const theta = THREE.MathUtils.degToRad(thetaDeg); const phi = THREE.MathUtils.degToRad(phiDeg); const x = radius * Math.cos(phi) * Math.cos(theta); const y = radius * Math.sin(phi); const z = radius * Math.cos(phi) * Math.sin(theta); return new THREE.Vector3(x,y,z); }
  function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); }

  // render & refresh at start
  refreshPins();
  renderZonePills();
  renderItemsPanel();
  resize();

  // small debug: show helpful message if WebXR not present
  if(!navigator.xr) console.log("WebXR not available. Use Export GLB for device AR viewing (Quick Look on iOS).");

  </script>
</body>
</html>

