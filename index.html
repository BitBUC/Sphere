<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>SPHERE — Quick Fallback (visual restore)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#f3f6fb}
    .top{display:flex;justify-content:space-between;align-items:center;padding:12px;background:#fff;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
    .btn{padding:8px 12px;border-radius:8px;border:1px solid #dfe8ff;background:#fff;cursor:pointer;margin-left:8px;font-weight:600}
    .btn.primary{background:#2b6ef6;color:#fff;border:0}
    #canvas{width:100%;height:calc(100vh - 64px);display:block}
    .note{color:#667085;font-size:13px}
  </style>
</head>
<body>
  <div class="top">
    <div>
      <strong>SPHERE — Fallback</strong><div class="note">Simple visual restore (non-module)</div>
    </div>
    <div>
      <button class="btn" id="prev">Prev</button>
      <button class="btn" id="spin">Spin</button>
      <button class="btn" id="next">Next</button>
      <button class="btn primary" id="export">Export GLB</button>
    </div>
  </div>

  <canvas id="canvas"></canvas>

  <!-- Use Three r149 (non-module) and exporter that attach to global THREE -->
  <script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.149.0/examples/js/exporters/GLTFExporter.js"></script>

  <script>
  // Minimal restore demo: sphere + 6 large labels + simple spin + GLB export
  (function(){
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, 2, 0.1, 2000);
    camera.position.set(0,0,700);
    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
    scene.add(light);

    const group = new THREE.Group();
    scene.add(group);

    const sphere = new THREE.Mesh(new THREE.SphereGeometry(200, 48, 48), new THREE.MeshStandardMaterial({color:0xf7fbff, metalness:0.02, roughness:0.7}));
    group.add(sphere);

    // zones & items (simple)
    const ZONES = ["Ideas","Tasks","People","Rituals","Mindset","Someday"];
    const items = {
      "Ideas":["Sketch","Scent"], "Tasks":["Call","Order"], "People":["JHANE","Maeve"],
      "Rituals":["Stretch"], "Mindset":["Gratitude"], "Someday":["Visit Japan"]
    };

    // label utility (bigger)
    function makeLabelCanvas(text, fontSize=34){
      const padding = 18;
      const font = 'bold ' + fontSize + 'px Arial';
      const measure = document.createElement('canvas');
      const mctx = measure.getContext('2d'); mctx.font = font;
      const w = Math.max(140, Math.ceil(mctx.measureText(text).width + padding*2));
      const h = Math.max(60, fontSize + 18);
      const canvas = document.createElement('canvas'); canvas.width=w; canvas.height=h;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = '#eaf2ff';
      roundRect(ctx,0,0,w,h,12);
      ctx.fillStyle = '#15304f';
      ctx.font = font; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(text, w/2, h/2 + 1);
      return canvas;
    }
    function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill(); }

    // place labels around equator
    const markers = [];
    for(let i=0;i<6;i++){
      const theta = i*(360/6);
      const pos = sphericalToCartesian(201, theta, 0);
      const c = makeLabelCanvas(ZONES[i], 36);
      const tex = new THREE.CanvasTexture(c);
      const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
      sprite.scale.set(c.width*0.25, c.height*0.25, 1);
      sprite.position.copy(pos);
      sprite.userData = {zone:i};
      group.add(sprite);
      markers.push(sprite);
    }

    // small top item pins
    for(let i=0;i<6;i++){
      const text = items[ZONES[i]][0] || "(empty)";
      const c = makeLabelCanvas(text,20);
      const tex = new THREE.CanvasTexture(c);
      const s = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
      const pos = sphericalToCartesian(204, i*(360/6)+18, 12);
      s.position.copy(pos); s.scale.set(c.width*0.18, c.height*0.18, 1);
      group.add(s);
    }

    function sphericalToCartesian(radius, thetaDeg, phiDeg){
      const theta = thetaDeg * Math.PI/180;
      const phi = phiDeg * Math.PI/180;
      const x = radius * Math.cos(phi) * Math.cos(theta);
      const y = radius * Math.sin(phi);
      const z = radius * Math.cos(phi) * Math.sin(theta);
      return new THREE.Vector3(x,y,z);
    }

    // resize
    function resize(){ const w = canvas.clientWidth || window.innerWidth; const h = canvas.clientHeight || window.innerHeight - 64; renderer.setSize(w,h); camera.aspect = w/h; camera.updateProjectionMatrix(); }
    window.addEventListener('resize', resize); resize();

    // spin
    let rotY = 0, vel = 0, isDown=false, lastX=0;
    const sensitivity=0.008, damping=0.94;
    canvas.addEventListener('mousedown', e=>{ isDown=true; lastX=e.clientX; vel=0; });
    canvas.addEventListener('mousemove', e=>{ if(!isDown) return; const dx=e.clientX-lastX; lastX=e.clientX; const d = dx*sensitivity; rotY += d; vel = d; });
    window.addEventListener('mouseup', ()=>{ if(!isDown) return; isDown=false; snapToNearest(); });

    canvas.addEventListener('touchstart', e=>{ isDown=true; lastX=e.touches[0].clientX; vel=0; }, {passive:true});
    canvas.addEventListener('touchmove', e=>{ if(!isDown) return; const dx=e.touches[0].clientX-lastX; lastX=e.touches[0].clientX; const d = dx*sensitivity; rotY += d; vel = d; }, {passive:true});
    window.addEventListener('touchend', ()=>{ if(!isDown) return; isDown=false; snapToNearest(); });

    function nearestZoneFromRot(r){
      const fraction = ((-r / (2*Math.PI)) % 1 + 1) % 1;
      return Math.round(fraction*6) % 6;
    }
    let targetRot = null;
    function snapToNearest(){ const n = nearestZoneFromRot(rotY); const desiredFrac = n/6; const curFrac = ((-rotY/(2*Math.PI))%1+1)%1; let diff = desiredFrac - curFrac; if(diff>0.5) diff -=1; if(diff<-0.5) diff +=1; targetRot = rotY - diff*2*Math.PI; }

    // buttons
    document.getElementById('prev').addEventListener('click', ()=> { snapToNearest(); targetRot += (2*Math.PI)/6; });
    document.getElementById('next').addEventListener('click', ()=> { snapToNearest(); targetRot -= (2*Math.PI)/6; });
    document.getElementById('spin').addEventListener('click', ()=>{ let spins=12+Math.floor(Math.random()*10), i=0; const iv=setInterval(()=>{ rotY -= (2*Math.PI)/6; i++; if(i>=spins){ clearInterval(iv); snapToNearest(); } }, 60); });

    // click raycast
    const ray = new THREE.Raycaster(); const pointer = new THREE.Vector2();
    canvas.addEventListener('click', function(e){
      const rect = canvas.getBoundingClientRect();
      pointer.x = ((e.clientX - rect.left)/rect.width)*2 -1;
      pointer.y = -((e.clientY - rect.top)/rect.height)*2 +1;
      ray.setFromCamera(pointer, camera);
      const ints = ray.intersectObjects(markers, true);
      if(ints.length){ const z = ints[0].object.userData.zone; alert('Zone: ' + ZONES[z]); snapToZone(z); }
    });

    function snapToZone(i){ const desired = i/6; const cur = ((-rotY/(2*Math.PI))%1+1)%1; let diff=desired-cur; if(diff>0.5) diff-=1; if(diff<-0.5) diff+=1; targetRot = rotY - diff*2*Math.PI; }

    // render loop
    function animate(){
      requestAnimationFrame(animate);
      if(!isDown){ vel *= damping; rotY += vel; if(targetRot !== null){ rotY += (targetRot - rotY)*0.18; if(Math.abs(targetRot - rotY) < 0.0005){ rotY = targetRot; targetRot = null; } } }
      group.rotation.y = rotY;
      renderer.render(scene, camera);
    }
    animate();

    // GLB export (simple)
    const exporter = new THREE.GLTFExporter();
    document.getElementById('export').addEventListener('click', ()=>{
      try {
        const exportScene = new THREE.Scene();
        const s = new THREE.Mesh(sphere.geometry.clone(), new THREE.MeshStandardMaterial({color:0xf7fbff}));
        exportScene.add(s);
        // little label boxes
        const mat = new THREE.MeshStandardMaterial({color:0x2b6ef6});
        for(let i=0;i<6;i++){ const g = new THREE.BoxGeometry(8,8,2); const m = new THREE.Mesh(g, mat); const p = sphericalToCartesian(220, i*(360/6), 0); m.position.copy(p); exportScene.add(m); }
        exporter.parse(exportScene, function(result){
          if(result instanceof ArrayBuffer){
            const blob = new Blob([result], {type:'model/gltf-binary'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'sphere_scene.glb'; a.click(); URL.revokeObjectURL(url);
            alert('GLB exported.');
          } else {
            const txt = JSON.stringify(result, null, 2);
            const blob = new Blob([txt], {type:'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href=url; a.download='sphere_scene.gltf'; a.click(); URL.revokeObjectURL(url);
            alert('GLTF exported.');
          }
        }, {binary:true});
      } catch(err){ console.error(err); alert('Export failed: '+err); }
    });

    // done
  })();
  </script>
</body>
</html>
